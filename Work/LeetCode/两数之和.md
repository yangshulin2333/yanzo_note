

# 两数之和问题

## 问题描述

给定一个整数数组 `nums` 和一个目标值 `target`，在数组中找出和为目标值的那两个整数，并返回它们的数组下标。

**示例**：
```plaintext
输入：nums = [2, 7, 11, 15], target = 9
输出：[0, 1]
解释：因为 nums[0] + nums[1] == 9，所以返回 [0, 1]。
```

## 解法一：暴力解法

### 思路

- 使用双重循环遍历所有可能的两数组合，寻找符合条件的两个数。

### 实现

```csharp
public int[] TwoSum(int[] nums, int target) {
    for (int i = 0; i < nums.Length; i++) {
        for (int j = i + 1; j < nums.Length; j++) { // j = i + 1 确保不重复且不自加
            if (nums[i] + nums[j] == target) {
                return new int[] { i, j };
            }
        }
    }
    return null;
}
```

### 复杂度分析

- **时间复杂度**：O(N^2)。
- **空间复杂度**：O(1)。

### 注意事项

- `j = i + 1` 确保从当前位置之后开始寻找，避免重复和自加。

## 解法二：使用哈希表

### 思路

- 用字典（哈希表）存储每个数值和其索引，实现快速查找。

### 实现

```csharp
public int[] TwoSum(int[] nums, int target) {
    Dictionary<int, int> map = new Dictionary<int, int>(); // 初始化字典
    for (int i = 0; i < nums.Length; i++) {
        int complement = target - nums[i];
        if (map.ContainsKey(complement)) {
            return new int[] { map[complement], i };
        }
        map[nums[i]] = i; // 存储当前数值及其索引
    }
    return null;
}
```

### 复杂度分析

- **时间复杂度**：O(N)。
- **空间复杂度**：O(N)。

### 语法说明

- `Dictionary<int, int> map = new Dictionary<int, int>();`
  - 声明并初始化一个字典，键值对的类型均为整数。
  - 用于快速查找已遍历的数及其索引。

### 例子讲解

假设 `nums = [3, 4, 6], target = 10`：

1. 初始化空字典 `map`。
2. 遍历第一个元素3，计算补数为7，字典中无7，存入字典 `{3: 0}`。
3. 继续遍历到4，计算补数为6，字典中无6，更新字典 `{3: 0, 4: 1}`。
4. 到元素6，计算补数为4，补数存在于字典中，返回 `[1, 2]`。

## 相关知识点

### 时间复杂度

- **O(1)**: 常数时间复杂度。
- **O(N)**: 线性时间复杂度。
- **O(N^2)**: 平方时间复杂度。

### 空间复杂度

- **O(1)**: 常数空间复杂度。
- **O(N)**: 线性空间复杂度。

### 时间与空间的权衡

- 提高时间效率有时需增加空间使用，反之亦然。
- 选择合适的解法需根据具体需求和限制权衡。

### 算法优化技巧

- 使用高效的数据结构如哈希表降低时间复杂度。
- 精简代码逻辑，减少不必要的计算。

## 总结

- 暴力解法简单，但在大规模数据下效率较低。
- 哈希表解法高效，适用于大规模数据。
- 根据实际情况，综合考虑时间与空间效率选择合适解法。
```

如有其他问题，欢迎随时提问。再次感谢你的耐心！