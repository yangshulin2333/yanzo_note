
z## 泛型
### 定义
泛型实现了类型参数化，达到代码重用目的。
相当于类型占位符
定义类 或方法时 使用 替代符 代表变量类型
当真正使用类 或者 方法 时再具体指定类型
### 泛型分类
#### 泛型类和接口
基本语法：
`class 类型<泛型占位字母>`
`interface 接口名<泛型占位字母>`
#### 泛型函数
基本语法：
`函数名<泛型占位符字母>{参数列表}`

注意：泛型占位字母可以有多个，用逗号分开

### 泛型方法
#### 普通类中的泛型方法
#### 泛型类中的泛型方法

泛型的作用
1. 不同类型对象的相同逻辑处理就可以选择泛型
2. 使用泛型可以一定程度避免装箱拆箱

## List、ArrayList和LinkedList
这也是 C# 面试和实际开发中最基础、最重要的问题之一。我们可以把它们想象成三种**“存放数据的容器”**。

简单总结它们的地位：

1. **`List<T>`**：**现代王牌**。95% 的情况下你都应该用它。
    
2. **`ArrayList`**：**远古化石**。C# 1.0 时代的产物，除非维护老代码，否则**千万别用**。
    
3. **`LinkedList<T>`**：**特种部队**。只在极特殊的场景（频繁在中间插入/删除）下使用。
    
---
### 1. ArrayList（被淘汰的旧时代容器）

它是 C# 最早期的动态数组。

- **特点**：它是个“大杂烩”，里面存的都是 `object` 类型。
    
- **致命缺点 1（不安全）**：因为它什么都能存，你很容易把“苹果”和“砖头”混在一起，取出来时容易报错。
    
- **致命缺点 2（性能差 - 装箱/拆箱）**：
    
    - 你把 `int`（值类型）存进去，它必须被包装成 `object`（引用类型），这叫**装箱**（Boxing）。
        
    - 你取出来用，又得变回 `int`，这叫**拆箱**（Unboxing）。
        
    - **比喻**：就像你要存一件衣服，必须先把它装进快递盒（装箱），拿出来穿又要拆快递盒（拆箱）。如果你存 100 万个数字，就要拆装 100 万次快递盒，非常浪费性能！
        

**代码反面教材：**

CSharp

```
ArrayList list = new ArrayList();
list.Add(1);       // 存入整数
list.Add("文本");   // 存入字符串（竟然允许！）
list.Add(true);    // 存入布尔值

// 下面这行会报错，因为第二个元素是 string，转不成 int
int number = (int)list[1]; // 💣 运行时崩溃！
```

---
### 2. List`<T>`（现代标准容器）

它是 `ArrayList` 的**泛型进化版**。

- **特点**：**连续内存**。就像一排紧挨着的储物柜。
    
- **优点**：
    
    - **类型安全**：定义 `List<int>` 后，只能存 int，编译器会帮你检查。
        
    - **无装箱**：存 int 就是 int，没有性能损耗。
        
    - **查找极快**：因为内存是连续的，你想访问 `list[5]`，电脑能直接算出它的内存地址，瞬间到达。
        
- **缺点**：
    
    - **插入/删除慢**：如果你在第 0 位插入一个元素，原来第 0 位及后面的所有元素都要**向后挪动**一位，给新来的腾位置。就像排队插队一样，后面的人都要动。
        

```
List<int> list = new List<int>();
list.Add(1);
// list.Add("文本"); // ❌ 编译直接报错，甚至不让你运行
int number = list[0]; // 不需要强制转换，非常快
```

---

### 3. LinkedList`<T>`（链表）

它是一种**链式结构**。

- **特点**：**分散内存**。就像寻宝游戏，每个元素（节点）手里都攥着一张纸条，写着“下一个元素在哪里”。元素在内存里是散落的。
    
- **优点**：
    
    - **插入/删除极快**：想在中间加个人？只需要改一下前后两个人的“纸条”指向就行了，其他人完全不用动。
        
- **缺点**：
    
    - **查找极慢**：你想找第 100 个元素？对不起，不能直接跳过去。你必须从第 1 个开始，顺着纸条找到第 2 个，再找第 3 个……一直跑到第 100 个。**它不支持 `list[index]` 这种索引访问。**
        

结构示意图：

[值:1 | 下一个在哪里?] --> [值:2 | 下一个在哪里?] --> ...

---

### 总结对比表

| **特性**           | **ArrayList**  | **List<T>**    | **LinkedList<T>**         |     |
| ---------------- | -------------- | -------------- | ------------------------- | --- |
| **底层结构**         | 数组 (Array)     | 数组 (Array)     | 双向链表 (Doubly Linked List) |     |
| **类型安全**         | ❌ 无 (存 object) | ✅ 有 (泛型)       | ✅ 有 (泛型)                  |     |
| **随机访问** (`[i]`) | 快              | **最快**         | ❌ 不支持 (必须逐个遍历)            |     |
| **中间插入/删除**      | 慢 (需要搬移数据)     | 慢 (需要搬移数据)     | **极快** (只需修改指针)           |     |
| **内存占用**         | 高 (装箱开销)       | 低              | 中 (每个数据都要多存引用地址)          |     |
| **推荐指数**         | **⭐ (别用)**     | **⭐⭐⭐⭐⭐ (首选)** | **⭐⭐ (特定场景用)**            |     |

### 怎么选？

1. **闭眼选 `List<T>`**：除非你有明确理由不选它。
    
    - 比如做游戏里的背包系统、敌人的列表、分数的记录，全用 `List<T>`。
        
2. **只有一种情况选 `LinkedList<T>`**：
    
    - 你需要**频繁地**在列表的**中间**插入或删除大量数据，而且你**不需要**用索引（`[5]`）去查数据，只是按顺序轮询。
        
3. **永远不要选 `ArrayList`**：
    
    - 忘记它的存在。

## 字典
关键字：
`Dictionary`

本质：
可以将Dictionary理解为 拥有泛型的 Hashtable
它也是基于键的哈希代码组织起来的 键/值对
键值对类型 从Hashtable的object变为了 可以自己定制的泛型

申明：
//需要引用命名空间using System.Collections.Generic
Dictionary<int,string> dictionary = new Dictionary<int,string>();

注意：
不能出现相同的键 


## 委托
[CSharp 委托与事件 (Delegate & Event) 实战教学笔记](知识点/CSharp%20委托与事件%20(Delegate%20&%20Event)%20实战教学笔记.md)

### 定义
- **委托是 函数(方法)的容器**，可以理解为 表示函数（方法）的变量类型。
- 用来 存储、传递函数（方法）。
- 委托的本质是一个类，用来定义函数（方法）的类型（返回值和参数的类型）
- 不同的 函数（方法）必须对应和 各自“格式”一致的委托

关键字：
delegate
### 定义语法（造模具）：
```
访问修饰符 delegate 返回值 委托名(参数列表);
```
声明事件（使用模具）：
```
访问修饰符 event 委托类型 事件名;
```
访问修饰符不写默认为public，可以申明在namespace 和 class语句块中

委托规则的申明是不能重名 

### 委托常用在：
1. 作为类的成员
2. 作为函数的参数

### 委托变量可以存储多个函数(多播委托)

- 多播委托（Multicast Delegate），也就是“一个信号，触发多个动作”。

### 系统定义好的常用委托

#### 【破局者笔记】 C# 委托御三家 (The Big Three)

##### 1. Action (行动派)
- **口诀：** **只干活，不废话（返回 void）。**
- **应用场景：** UI 按钮点击、Input System 按键触发、简单的广播通知。
- **泛型规则：** `< >` 里全是参数。

```CSharp
using System; // 必须引用 System 命名空间

public class ActionExample : MonoBehaviour {
    // 定义：我要一个事件，触发时要把“死因(string)”传出去
    public event Action<string> OnPlayerDied;

    void Start() {
        // 订阅 (+=)：只要符合 void 方法名(string) 就能连
        OnPlayerDied += GameOverLogic;
        
        // 触发 (Invoke)：喊那一嗓子
        OnPlayerDied?.Invoke("掉进坑里了");
    }

    // 符合签名的方法
    void GameOverLogic(string reason) {
        Debug.Log("游戏结束，原因：" + reason);
    }
}
```

---

##### 2. Func (计算派)

- **口诀：** **屁股（最后一个）才是结果，前面全是入参。**
- **应用场景：** 只需要计算结果、判断条件（LINQ）、从别的地方“偷”数据。
- **泛型规则：** `Func<入参1, 入参2, ..., 返回值>`
C#
```
using System;

public class FuncExample : MonoBehaviour {
    // 定义：哪怕你不知道金币怎么算的，但你需要一个“输入花费(int)，返回能不能买(bool)”的计算器
    // int = 入参 (花费多少)
    // bool = 返回值 (能买吗？)
    public Func<int, bool> CheckCanAfford;

    void Start() {
        // 赋值：这里用 Lambda 表达式写了个匿名函数
        // x 代表入参 int
        CheckCanAfford = (x) => {
            return x <= 100; // 假设玩家有100块，如果花费 x 小于等于 100 就返回 true
        };

        // 使用：直接像调用函数一样用它，并拿到返回值
        bool result = CheckCanAfford(50); // 返回 true
        bool result2 = CheckCanAfford(200); // 返回 false
    }
}
```
##### 3. EventHandler (官方派)
- **口诀：** **讲礼貌，守规矩。必须带两个特定的参数。**
- **应用场景：** 遵循微软标准事件模式、Code Monkey 教程里的交互系统。
- **固定签名：** `void 方法名(object 发送者, EventArgs 参数包)`
C#
```
using System;

public class EventHandlerExample : MonoBehaviour {
    // 定义：不需要写尖括号（除非你有自定义参数类），它是最标准的写法
    public event EventHandler OnInteract;

    void Start() {
        // 订阅
        OnInteract += MyInteractFunction;

        // 触发：
        // 参数1 (this): 告诉别人“是我发的”
        // 参数2 (EventArgs.Empty): 告诉别人“我没有额外数据要传，纯打个招呼”
        OnInteract?.Invoke(this, EventArgs.Empty);
    }

    // 符合签名的方法：必须带 sender 和 e
    void MyInteractFunction(object sender, EventArgs e) {
        Debug.Log("收到！有人按了互动键！");
    }
}
```
#### 【总结图谱】
[](总结图谱)
**这三张卡片存好，以后遇到委托的问题，拿出来看一眼，秒懂！**



## 事件
基于委托封装的“通知机制”，实现了 **发布者 (Publisher)** 与 **订阅者 (Subscriber)** 的解耦。
防止外部随意置空、调用委托

