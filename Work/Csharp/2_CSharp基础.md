
### 复杂数据类型
1. **枚举：** 是整数常量的集合，可以自定义。
2. **数组：** 可以存储任意变量类型的数据，按顺序存储。
3. **结构体：** 是任意变量的数据集合，可以自定义。
#### 枚举
```
//申明枚举语法
enum E_自定义枚举名{
	自定义枚举项名字,  //枚举中包裹的 整型常量 第一个默认值是0，后面依次累加
	自定义枚举项名字1 = 5,//默认值是5，后面依次累加
	自定义枚举项名字2, //6
}
//声明枚举变量
自定义枚举类型 变量名 = 枚举类型的默认值
```
- 枚举不能在函数语句块中声明，一般在namespace语句块中声明
### 数组
#### 一维数组
```
//声明数组
变量类型[] 数组名;
变量类型[] 数组名 = new 变量类型[数组长度];
变量类型[] 数组名 = new 变量类型[数组长度]{内容1,内容2,...... };
变量类型[] 数组名 = new 变量类型[]{内容1,内容2,...... };
```
数组初始化后，不可以直接增删元素
#### 二维数组
```
变量类型[,] arr;
变量类型[,] arr2 = new 变量类型 [行, 列];
变量类型[,] arr2 = new 变量类型 [行, 列]{{内容1},{内容2},......};
变量类型[,] arr2 = {};
arr2.GetLength(0);//行
arr2.GetLength(1);//列
```
#### 交错数组
```
//变量类型[][] 交错数组名;
//变量类型[][] 交错数组名 = new 变量类型[行数][];
//变量类型[][] 交错数组名 = new 变量类型[行数][]{一维数组1,一维数组2,......};
int[][] arrs = new int[3][]{
	new int[]{1,2,3},
	new int[]{1,2},
	new int[]{1}
}
//变量类型[][] 交错数组名 = new 变量类型[][]{一维数组1,一维数组2,......};
//变量类型[][] 交错数组名 = {一维数组1,一维数组2,......};
int[][] arrs2 = {
	new int[]{1,2,3},
	new int[]{1,2},
	new int[]{1}
}
arrs2.GetLength(0);//行
arrs2[0].Length//第0行有多少列
```
### 值类型和引用类型
在 C# 中，值类型和引用类型是两种不同的类型分类，它们的主要区别在于内存分配和存储方式。
![](assets/2_CSharp基础/file-20260106173353174.png)
#### 值类型
**值类型在相互赋值时 把内容拷贝给了对方 它变我不变**
1. **定义：** 
   - 值类型直接包含数据。
2. **存储位置：**
   - 值类型的实例通常在栈（stack）上创建。
3. **内存分配：**
   - 内存分配和释放效率较高，因为它们在栈上管理。
4. **赋值行为：**
   - 复制值，两个变量操作的不是同一个内存块。
5. **示例：**
   - 基本数据类型：`int`, `float`, `double`, `bool`, `char`
   - 结构体（`struct`）
#### 引用类型
**引用类型的相互赋值 是 让两者指向同一个值 它变我也变**
1. **定义：** 
   - 引用类型存储对数据的引用（指针），而不是直接存储数据。
2. **存储位置：**
   - 引用类型的实例通常在堆（heap）上创建。
3. **内存管理：**
   - 由垃圾回收（Garbage Collector）管理内存释放，性能可能受影响。
4. **赋值行为：**
   - 复制引用，多个变量可以指向相同的对象。
5. **示例：**
   - 类（`class`）
   - 接口（`interface`）
   - 数组（`array`）
   - 委托（`delegate`）
   - 字符串（`string`）
- **值类型**适用于需要频繁创建和销毁的对象，因为它们的管理效率更高。小而快
- **引用类型**适用于需要复杂对象和多态性功能，因为它们提供了更多的灵活性和功能。大而慢
#### 特殊引用类型string

### 函数
```
static 返回类型 函数名(参数类型 参数1,参数类型 参数2,......){

}
```


在 C# 中，`ref` 和 `out` 是用于参数传递修饰符，它们允许在方法中对参数进行修改，并将修改结果带回给调用者。以下是它们的区别和用法：

#### `ref` 修饰符

1. **用途：**
   - 允许参数在方法中被修改，并将修改后的值返回给调用者。

2. **要求：**
   - 在调用方法时，参数必须已经初始化。

3. **用法：**
   ```csharp
   void ModifyValue(ref int number)
   {
       number = 10;
   }

   int value = 5;
   ModifyValue(ref value);
   // value 现在为 10
   ```

#### `out` 修饰符

1. **用途：**
   - 也允许参数在方法中被修改，并将修改结果带回给调用者，通常用于返回多个值。

2. **要求：**
   - 参数在调用方法前可以不初始化，但方法内部必须对其赋值。

3. **用法：**
   ```csharp
   void GetValues(out int x, out int y)
   {
       x = 5;
       y = 10;
   }

   int a, b;
   GetValues(out a, out b);
   // a 现在为 5, b 为 10
   ```

- **`ref`**：参数必须在使用前初始化，适用于需要在方法内读写参数值的情况。
- **`out`**：参数可以在使用前未初始化，但方法内必须对其赋值，适用于需要返回多个结果的情况。
#### 变长参数

在C#中，`params`关键字用于允许方法接收可变数量的参数。这个参数必须是方法签名中的最后一个参数，并且必须是一个数组类型。使用`params`可以简化向方法传递多个参数的操作。

##### 基本用法

- **语法**：

  ```csharp
  void MyMethod(params int[] numbers)
  {
      foreach (int number in numbers)
      {
          Console.WriteLine(number);
      }
  }
  ```

- **调用方式**：

  你可以传递任意数量的参数，甚至不传递参数。

  ```csharp
  MyMethod(1, 2, 3, 4, 5);
  MyMethod(); // 空调用
  ```

- **数组传递**：

  如果你已经有一个数组，可以直接传递数组：

  ```csharp
  int[] myNumbers = { 1, 2, 3 };
  MyMethod(myNumbers);
  ```

##### 注意事项

- `params`参数必须是方法签名中的最后一个参数。
- 一个方法只能有一个`params`参数。
- 可以传递零个或多个参数，或者直接传递一个数组。

##### 实际应用

`params`关键字常用于需要灵活数量输入的情况，例如计算总和、连接字符串等。

```csharp
int Sum(params int[] numbers)
{
    int sum = 0;
    foreach (int num in numbers)
    {
        sum += num;
    }
    return sum;
}

// 示例调用
int total = Sum(1, 2, 3, 4); // total为10
```

使用`params`关键字可以提高方法的灵活性和可用性，尤其是在你无法预知具体参数数量的场景中。
#### 参数默认值
在C#中，参数默认值允许在方法声明时为参数指定一个默认值，这样调用方法时可以选择性地省略这些参数。

##### 语法

```csharp
void MyMethod(int x = 10, string s = "Hello")
{
    Console.WriteLine($"x: {x}, s: {s}");
}
```

##### 调用方式

- **使用默认值**：

  ```csharp
  MyMethod(); // 输出: x: 10, s: Hello
  ```

- **覆盖默认值**：

  ```csharp
  MyMethod(5, "World"); // 输出: x: 5, s: World
  ```

- **部分覆盖**：

  如果想仅修改某个默认值参数，可以使用命名参数：

  ```csharp
  MyMethod(s: "C#"); // 输出: x: 10, s: C#
  ```

##### 注意事项

1. **参数顺序**：带有默认值的参数必须放在方法参数列表的末尾。
 
2. **命名参数**：可以结合命名参数来提高调用的灵活性。

3. **编译时常量**：默认值必须是编译时常量。

##### 用途

- 简化方法重载，减少重载数量。
- 提高方法的灵活性，使方法调用更加方便。
#### 重载
#### 递归函数
让函数自己 调用自己


#### 结构体

##### 什么是结构体?

结构体（Struct）是一种值类型数据结构，用于组合多个相关的数据类型。与类类似，但更加轻量级。

##### 特点

1. **值类型**:
   - 与类（引用类型）不同，结构体是值类型。这意味着它们被存储在堆栈上（在大多数情况下），而不是堆上。

2. **不可继承**:
   - 结构体不能继承自其他结构体或类，也不能被继承。

3. **构造函数**:
   - 可以定义带参数的构造函数，但不能定义无参数的构造函数（编译器提供默认的无参数构造函数）。
   - 所有字段必须在构造函数中完全初始化。

4. **无默认初始化**:
   - 结构体的字段没有默认初始化。程序员必须确保显式初始化。

##### 何时使用

- 当你需要一个轻量级对象，且不需要复杂的行为或继承时。
- 在希望较少内存分配和更高性能的场景中，适合使用结构体。

##### 示例

```csharp
public struct Point
{
    public int X { get; set; }
    public int Y { get; set; }

    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }

    public void Display()
    {
        Console.WriteLine($"X: {X}, Y: {Y}");
    }
}
```

##### 使用示例

```csharp
Point p1 = new Point(10, 20);
Point p2 = p1; // 复制结构体，值被复制

p2.X = 30; // 改变 p2 不影响 p1

Console.WriteLine($"p1: ({p1.X}, {p1.Y})"); // 输出: p1: (10, 20)
Console.WriteLine($"p2: ({p2.X}, {p2.Y})"); // 输出: p2: (30, 20)
```

##### 注意事项

- **内存效率**: 由于值类型在传递时会被复制，如果结构体很大，内存开销可能会较高。
- **不可变建议**: 设计结构体时，建议尽量设计成不可变类型（只读属性），这可以避免误用。
- **接口实现**: 可以实现接口，但无法继承其他结构体或类。

结构体可以在需要简单数据存储和传递时使用，尤其是在性能关键的应用中。
#### 冒泡排序
- 两两相邻
- 不断比较
- 不断交换
- 比较n轮
#### 选择排序
- 新建中间商
- 依次比较
- 找出极值(最大或最小)
- 放入目标位置
- 比较n轮